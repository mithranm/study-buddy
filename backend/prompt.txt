main.py
```
@bp.route('/upload', methods=['POST'])
def upload_file():
    """
    Uploads a file that is chosen by the user.

    This function handles all POST request to the '/upload' endpoint.

    Args:
        None
    Returns:
        tuple: a json of the message and the http code
        if successful: ({'message': 'File uploaded and embedded sucessfully'}, 200)
        if backend not ready: ({'error': 'Backend is not fully initialized yet'}, 503)
        if theres no file to upload: ({'error': 'No file part'}, 400)
        if filename is empty: ({'error': 'No selected file'}, 400)
    """
    if 'file' not in request.files:
        return jsonify({'error': 'No file part'}), 400
    file = request.files['file']
    if file.filename == '':
        return jsonify({'error': 'No selected file'}), 400
    if file:
        file_path = os.path.join(current_app.config['UPLOAD_FOLDER'], file.filename)

        collection = vector_db.get_collection()
        # Checks to see if the file already exists in the upload directory to prevent from the file being chunked again in chroma db.

        if(os.path.exists(file_path) and len(collection.get(where={"source": file_path})['ids'])): # Also checks the data base just to make sure no funny business is going on
            return jsonify({"error": "Tried uploading a file that already exists."}), 400
        
        file.save(file_path)

        # Sending a task to complete adding to db in the background.
        process_file.delay(file.filename, file_path, current_app.config["TEXTRACTED_PATH"]) # <--- calling process_file from task.py

        return jsonify({'message': 'File recieved and is being processed', 'filename': file.filename}), 202

@bp.route('/task_status/<task_id>') # made it task_id to add more scalability.
def task_status(task_id):
    # integrate status reports to frontend here.
```

This is how I am making my celery app.
```
app.config.from_mapping(
        CHROMA_HOST=os.getenv("CHROMA_HOST", "localhost"),  # Service name if using Docker Compose
        CHROMA_PORT=os.getenv("CHROMA_PORT", "9092"),        # Port exposed by ChromaDB server
        CELERY=dict(
            broker_url=os.getenv("REDIS_URL", "redis://localhost:6379/0"),
            result_backend=os.getenv("REDIS_URL", "redis://localhost:6379/0"),
            task_ignore_result=True,
        ),
    )
```

task.py
```
@shared_task(bind=True)
def process_file(self, file_path, textracted_path):
    """
    Where threads start to process files and embed them into the data base.

    Args:
        self: String contains filename.
        file_path: String contains the path of the file.
        textracted_path: String contains the path to the textracted directory.

    Returns:
        None
    """

    try:
        # Log the start of the processing
        logger.info(f"Starting to process file: {self}")

        self.update_state()

        collection = vector_db.get_collection()

        chunker.embed_documents([file_path], collection, textracted_path)

        # Log successful processing
        logger.info(f"Successfully processed file: {self}")

    except Exception as e:
        logger.error(f"Error processing file {self}: {str(e)}")
        # Optionally, you can raise the exception to retry the task if needed
        # raise e
```

How can I use redis to send status to the frontend. integrate this into task_status